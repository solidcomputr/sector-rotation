<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sector Rotation (Live)</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --card-bg: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-blue: #007bff;
            --grid-color: #e0e0e0;
            --crosshair-color: #666;
        }

        [data-theme="dark"] {
            --bg-color: #000000;
            --card-bg: #121212;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #333;
            --accent-blue: #4dabf7;
            --grid-color: #333;
            --crosshair-color: #888;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            text-align: center;
            background-color: var(--bg-color);
            color: var(--text-primary);
            padding: 20px;
            transition: background 0.3s, color 0.3s;
        }

        h1 { margin-bottom: 20px; font-weight: 300; text-transform: uppercase; letter-spacing: 1px; }

        .header-row {
            display: flex; justify-content: space-between; align-items: center;
            max-width: 1100px; margin: 0 auto 20px auto;
        }
        
        .theme-switch-wrapper { display: flex; align-items: center; gap: 10px; font-weight: bold; font-size: 0.9em; }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(24px); }

        #controls, #chart-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 1100px;
            margin: 0 auto 25px auto;
            padding: 25px;
            transition: background 0.3s, border 0.3s;
        }

        #chart-container { width: 100%; height: 800px; }

        #btn-row { margin-bottom: 20px; display: flex; justify-content: center; gap: 10px; }
        button { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9em; transition: 0.2s; }
        button.select-btn { background: var(--accent-blue); color: white; }
        button.select-btn:hover { opacity: 0.9; }
        button.clear-btn { background: #e0e0e0; color: #333; }
        button.clear-btn:hover { background: #ccc; }

        #checkbox-container {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 12px;
            margin-bottom: 25px; padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .sector-label {
            font-size: 0.85em; cursor: pointer; display: flex; align-items: center; gap: 8px;
            padding: 8px 12px; border-radius: 4px;
            background: rgba(128, 128, 128, 0.1); border: 1px solid transparent; color: var(--text-primary);
        }
        .sector-label:hover { background: rgba(128, 128, 128, 0.2); }
        .ticker-span { font-weight: 700; }

        input[type=range] { width: 100%; cursor: pointer; margin-top: 15px; accent-color: var(--accent-blue); }
        #date-display { font-size: 1.6em; font-weight: 600; display: block; margin-bottom: 5px; color: var(--text-primary); }
        #sub-text { color: var(--text-secondary); font-size: 0.9em; display: block; margin-bottom: 10px;}
        .highlight { color: var(--accent-blue); }
        .time-labels { display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.8em; color: var(--text-secondary); }
    </style>
</head>
<body>

    <div class="header-row">
        <h1>Sector Rotation</h1>
        <div class="theme-switch-wrapper">
            <span>Dark Mode</span>
            <label class="theme-switch">
                <input type="checkbox" id="darkModeToggle" onclick="toggleTheme()">
                <span class="slider"></span>
            </label>
        </div>
    </div>

    <div id="controls">
        <div id="btn-row">
            <button class="select-btn" onclick="toggleAll(true)">Select All</button>
            <button class="clear-btn" onclick="toggleAll(false)">Clear All</button>
        </div>

        <div id="checkbox-container">Loading sectors...</div>

        <span id="date-display">Initializing...</span>
        <span id="sub-text">Connecting to market data feed...</span>
        
        <input type="range" id="stepSlider" min="0" max="6" value="6" step="1" disabled>
        <div class="time-labels">
            <span>Oldest (7 Weeks Ago)</span>
            <span>Newest (Today)</span>
        </div>
    </div>

    <div id="chart-card">
        <div id="chart-container"></div>
    </div>

    <script>
        const delay = ms => new Promise(res => setTimeout(res, ms));
        const CUTOFF_TIMESTAMP = new Date("2025-12-23").getTime() / 1000;

        const SECTOR_MAP = [
            { tick: 'XLK', name: 'Technology', color: '#1f77b4' },
            { tick: 'XLF', name: 'Financials', color: '#ff7f0e' },
            { tick: 'XLV', name: 'Healthcare', color: '#2ca02c' },
            { tick: 'XLC', name: 'Comm. Services', color: '#d62728' },
            { tick: 'XLY', name: 'Discretionary', color: '#9467bd' },
            { tick: 'XLI', name: 'Industrials', color: '#8c564b' },
            { tick: 'XLP', name: 'Staples', color: '#e377c2' },
            { tick: 'XLE', name: 'Energy', color: '#7f7f7f' },
            { tick: 'XLU', name: 'Utilities', color: '#bcbd22' },
            { tick: 'XLRE', name: 'Real Estate', color: '#17becf' },
            { tick: 'XLB', name: 'Materials', color: '#aec7e8' }
        ];

        let FINAL_DATA = {};
        let DATE_LABELS = [];
        let VISIBLE_SECTORS = new Set(SECTOR_MAP.map(s => s.tick)); 
        let IS_DARK_MODE = false;

        function toggleTheme() {
            const checkbox = document.getElementById('darkModeToggle');
            IS_DARK_MODE = checkbox.checked;
            if (IS_DARK_MODE) document.body.setAttribute('data-theme', 'dark');
            else document.body.removeAttribute('data-theme');
            let sliderVal = document.getElementById('stepSlider').value;
            if (Object.keys(FINAL_DATA).length > 0) updateChart(parseInt(sliderVal));
        }

        // --- NEW HELPER: Fetch via AllOrigins ---
        // This helper handles the special wrapping AllOrigins does to bypass CORS
        async function fetchYahooData(ticker) {
            const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=6mo`;
            // We use 'api.allorigins.win' which is friendlier to GitHub Pages
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(yahooUrl)}`;
            
            const response = await fetch(proxyUrl);
            const wrapper = await response.json();
            
            // AllOrigins puts the actual data inside a 'contents' string
            // We must parse that string to get the real Yahoo JSON
            const realData = JSON.parse(wrapper.contents);
            return realData;
        }

        async function startApp() {
            setupCheckboxes();

            const status = document.getElementById('sub-text');
            let rawData = {};
            let spyData = null;
            
            try {
                status.innerText = "Fetching Benchmark ($SPX)...";
                const json = await fetchYahooData('^GSPC');
                let result = json.chart.result[0];
                spyData = { prices: result.indicators.quote[0].close, times: result.timestamp };
            } catch (e) { 
                console.error("SPY Error", e);
                status.innerText = "Error: Could not load SPY data. Please refresh.";
                status.style.color = "red";
                return;
            }

            for (let i = 0; i < SECTOR_MAP.length; i++) {
                let ticker = SECTOR_MAP[i].tick;
                status.innerText = `Fetching ${ticker} (${i+1}/${SECTOR_MAP.length})...`;
                try {
                    const json = await fetchYahooData(ticker);
                    let result = json.chart.result[0];
                    rawData[ticker] = { prices: result.indicators.quote[0].close, times: result.timestamp };
                    await delay(200); 
                } catch (e) { console.error(e); }
            }

            status.innerText = "Processing Relative Strength...";
            status.style.color = "var(--text-secondary)";
            processData(rawData, spyData);
        }

        function setupCheckboxes() {
            const container = document.getElementById('checkbox-container');
            container.innerHTML = ''; 

            SECTOR_MAP.forEach(item => {
                const label = document.createElement('label');
                label.className = 'sector-label';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'sector-cb';
                checkbox.checked = true; 
                checkbox.value = item.tick;

                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) VISIBLE_SECTORS.add(item.tick);
                    else VISIBLE_SECTORS.delete(item.tick);
                    let sliderVal = document.getElementById('stepSlider').value;
                    if (Object.keys(FINAL_DATA).length > 0) updateChart(parseInt(sliderVal));
                });

                label.appendChild(checkbox);
                const tickSpan = document.createElement('span');
                tickSpan.className = 'ticker-span';
                tickSpan.style.color = item.color;
                tickSpan.innerText = item.tick;
                label.appendChild(tickSpan);
                label.appendChild(document.createTextNode(` (${item.name})`));
                container.appendChild(label);
            });
        }

        function toggleAll(selectAll) {
            const checkboxes = document.querySelectorAll('.sector-cb');
            VISIBLE_SECTORS.clear();
            checkboxes.forEach(cb => {
                cb.checked = selectAll;
                if (selectAll) VISIBLE_SECTORS.add(cb.value);
            });
            let sliderVal = document.getElementById('stepSlider').value;
            if (Object.keys(FINAL_DATA).length > 0) updateChart(parseInt(sliderVal));
        }

        function processData(rawData, spy) {
            let lastIndex = spy.times.length - 1;
            let targetIndices = [];
            for (let i = 0; i < 7; i++) {
                let idx = lastIndex - (i * 5);
                if (idx >= 0) targetIndices.unshift(idx);
            }

            DATE_LABELS = targetIndices.map(idx => {
                let d = new Date(spy.times[idx] * 1000);
                return d.toLocaleDateString("en-US", { day: 'numeric', month: 'short', year: 'numeric' });
            });

            SECTOR_MAP.forEach(item => {
                let ticker = item.tick;
                if (!rawData[ticker]) return;
                let prices = rawData[ticker].prices;
                let spyPrices = spy.prices;
                let points = [];

                targetIndices.forEach((idx, step) => {
                    if (spy.times[idx] < CUTOFF_TIMESTAMP) return; 
                    if (idx < 60) return; 

                    let spyTrend = (spyPrices[idx] - spyPrices[idx-60]) / spyPrices[idx-60];
                    let secTrend = (prices[idx] - prices[idx-60]) / prices[idx-60];
                    let rsRatio = 100 + ((secTrend - spyTrend) * 100);

                    let spyMom = (spyPrices[idx] - spyPrices[idx-10]) / spyPrices[idx-10];
                    let secMom = (prices[idx] - prices[idx-10]) / prices[idx-10];
                    let rsMom = 100 + ((secMom - spyMom) * 100);

                    // 6x Multiplier for 0-250 scale
                    let x = 100 + (rsRatio - 100) * 6;
                    let y = 100 + (rsMom - 100) * 6;

                    points.push({ x: x, y: y, date: DATE_LABELS[step] });
                });
                FINAL_DATA[ticker] = points;
            });

            setupSlider();
        }

        function setupSlider() {
            const slider = document.getElementById('stepSlider');
            const sub = document.getElementById('sub-text');
            let maxSteps = DATE_LABELS.length - 1;
            slider.max = maxSteps;
            slider.value = maxSteps;
            slider.disabled = false;
            sub.innerText = "Data loaded. Drag slider to move through time.";
            updateChart(maxSteps);
            slider.addEventListener('input', (e) => updateChart(parseInt(e.target.value)));
        }

        function updateChart(stepIndex) {
            let dateStr = DATE_LABELS[stepIndex] || "N/A";
            document.getElementById('date-display').innerHTML = `Snapshot Date: <span class="highlight">${dateStr}</span>`;

            let traces = [];

            SECTOR_MAP.forEach(item => {
                let ticker = item.tick;
                if (!VISIBLE_SECTORS.has(ticker)) return;
                if (!FINAL_DATA[ticker]) return;
                
                let visiblePoints = FINAL_DATA[ticker].filter((_, i) => i <= stepIndex);
                if (visiblePoints.length === 0) return;

                let xVals = visiblePoints.map(p => p.x);
                let yVals = visiblePoints.map(p => p.y);
                let color = item.color;

                traces.push({
                    x: xVals, y: yVals,
                    mode: 'lines+markers+text',
                    name: ticker,
                    line: { color: color, width: 3, shape: 'spline' },
                    marker: { 
                        size: 9, color: color,
                        opacity: xVals.map((_, i) => i === xVals.length - 1 ? 1 : 0.6),
                        line: {color: IS_DARK_MODE ? '#121212' : '#fff', width: 1} 
                    },
                    text: xVals.map((_, i) => i === xVals.length - 1 ? ticker : ''),
                    textposition: 'top center',
                    textfont: { family: 'Arial', weight: 'bold', size: 15, color: color },
                    hoverinfo: 'name+x+y'
                });
            });

            const cardBg = IS_DARK_MODE ? '#121212' : '#ffffff';
            const gridColor = IS_DARK_MODE ? '#333333' : '#e0e0e0';
            const textColor = IS_DARK_MODE ? '#a0a0a0' : '#666666';
            const crosshair = IS_DARK_MODE ? '#666666' : '#999999';

            const layout = {
                title: false,
                showlegend: false,
                paper_bgcolor: cardBg,
                plot_bgcolor: cardBg,
                font: { color: textColor },
                xaxis: { 
                    title: 'Relative Trend', range: [0, 250], 
                    zeroline: false, showgrid: true, gridcolor: gridColor 
                },
                yaxis: { 
                    title: 'Relative Momentum', range: [0, 250], 
                    zeroline: false, showgrid: true, gridcolor: gridColor 
                },
                margin: { l: 60, r: 40, b: 60, t: 30 },
                hovermode: 'closest',
                
                annotations: [
                    { x: 10, y: 240, text: 'Improving', showarrow: false, font: { size: 16, color: '#4dabf7', weight: 'bold' }, xanchor: 'left' },
                    { x: 240, y: 240, text: 'Leading', showarrow: false, font: { size: 16, color: '#2ca02c', weight: 'bold' }, xanchor: 'right' },
                    { x: 10, y: 10, text: 'Lagging', showarrow: false, font: { size: 16, color: '#d62728', weight: 'bold' }, xanchor: 'left' },
                    { x: 240, y: 10, text: 'Weakening', showarrow: false, font: { size: 16, color: '#ff7f0e', weight: 'bold' }, xanchor: 'right' }
                ],
                shapes: [
                    { type: 'line', x0: 100, y0: 0, x1: 100, y1: 250, line: { color: crosshair, width: 2 } },
                    { type: 'line', x0: 0, y0: 100, x1: 250, y1: 100, line: { color: crosshair, width: 2 } },
                    { type: 'rect', x0: 100, y0: 100, x1: 250, y1: 250, fillcolor: 'rgba(0, 200, 0, 0.03)', line: {width:0}},
                    { type: 'rect', x0: 0, y0: 0, x1: 100, y1: 100, fillcolor: 'rgba(200, 0, 0, 0.03)', line: {width:0}},
                    { type: 'rect', x0: 0, y0: 100, x1: 100, y1: 250, fillcolor: 'rgba(0, 0, 200, 0.03)', line: {width:0}},
                    { type: 'rect', x0: 100, y0: 0, x1: 250, y1: 100, fillcolor: 'rgba(255, 165, 0, 0.03)', line: {width:0}}
                ]
            };

            Plotly.react('chart-container', traces, layout);
        }

        startApp();
    </script>
</body>
</html>
